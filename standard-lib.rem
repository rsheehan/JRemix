	-====================-
==============================
 The Remix standard library
==============================
	-====================-

"Standard library loaded." ↲

==============================
 Simple print functions
==============================

=-
Print a new line character.
=-
new line :
	print "\n"

=-
Shortcut print call.
=-
(value) _ :
	print (value)

=-
Print a "value" followed by a space.
=-
(value) __ :
	print (value)
	print " "

=-
Print a "value" followed by a new line.
=-
/print (value) ↲/\n :
	print (value)
	new line

==============================
 Boolean functions
==============================

=-
Negate the "value".
=-
not (value) :
	if (value)
		return false
	true

=-
The boolean "and" operation.
=-
(valueA) and (valueB) :
	if (not (valueA))
		return false
	if (not (valueB))
		return false
	true

=-
The boolean "or" operation.
=-
(valueA) or (valueB) :
	if (valueA)
		return true
	if (valueB)
		return true
	false

==============================
 Looping functions
==============================

=-
Run "block" for each "item" in the "list".
"block" will usually refer to the variable passed as "item".
Return either the last statement result or whatever is returned from "block".
=-
for each (#item) in (list) do [block] :
	list-pos : start (list)
	do
		if (end (list-pos))
			return last
		#item : next (list-pos)
		- A return in the "block" following breaks out of the loop, with its result.
		last : do (block)
		redo

=-
Run "block" for each "number" from "start" to "finish".
=-
for each (#number) from (start) to (finish) do [block] :
	for each (#number) in ((start) to (finish)) do (block)

=-
Run "block" for each "item" in the "list" at all positions from "start" to "finish".
"start" to "finish" can go backwards.
"block" will usually refer to the variable passed as "item".
=-
for each (#item) in (list) from position (start) to (finish) do [block] :
	for each (pos) from (start) to (finish) do
		#item : list{pos}
		do (block)

=-
Run "block" for each "item" in the "list" keeping count in "count"
=-
for each (#item) in (list) keeping (#count) do [block] :
	#count : 0
	for each (#item) in (list) do
		inc (#count)
		do (block)

=-
Repeat the "block" for ever.
=-
repeat [block] forever :
	do (block)
	redo

=-
Repeat the "block" "count" number of times.
=-
repeat [block] (count) times :
	if (count ≤ 0)
		return last
	last : do (block)
	count : count - 1
	redo

=-
Repeat the "block" until the "condition" is true.
=-
repeat [block] until [condition] :
	last : do (block)
	if (condition)
		return last
	redo

=-
While a "condition" is true keep doing "block".
=-
while [condition] do [block] :
	if (not (condition))
		return last
	last : do (block)
	redo

==============================
 List create functions
==============================

=-
Filter "list" using "condition-block" on each "item".
=-
filter (list) by (#item) where [condition-block] :
	newlist : {}
	for each (#item) in (list) do
		if (condition-block)
			append (#item) to (newlist)
	newlist

=-
Collect items from "list" until "condition" is true.
The "condition" is checked before adding the "item".
=-
keep (#item) from (list) until [condition] :
	newlist : {}
	for each (#item) in (list) do
		if (condition)
			return
		append (#item) to (newlist)
	newlist

=-
Create a new list by applying "block" to each element of "list".
Uses the variable name passed as #item.
=-
apply [block] to each (#item) from (list) :
	newlist : {}
	for each (#item) in (list) do
		append (do (block)) to (newlist)
	newlist

=-
Create a new list by applying "block" "n" times.
=-
apply [block] (n) times :
	newlist : {}
	repeat
		append (do (block)) to (newlist)
	… (n) times
	newlist

==============================
 List reduce functions
==============================

=-
Can be used to construct list reduce functions.
"initial" is executed first.
Then each "item" in the "list" is executed in the "block".
=-
starting with [initial] apply [block] on each (#item) in (list) :
	do (initial)
	for each (#item) in (list) do
		do (block)

=-
Sum the "list" values.
=-
sum (list) :
	starting with
		sum : 0
	… apply
		sum : sum + number
	… on each (number) in (list)

=-
Multiply the "list" values.
=-
product (list):
	starting with
		product : 1
	… apply
		product : product × number
	… on each (number) in (list)

=-
Find the average of the elements in the "list".
=-
average of (list) :
	starting with
		sum : 0.0
	… apply
		sum : sum + item
	… on each (item) in (list)
	sum ÷ (length of (list))

=-
Find the average of "key" elements in the "list-of-maps".
The "key" should be passed as a string.
=-
average (key) of (list-of-maps) :
	starting with
		sum : 0.0
	… apply
		sum : sum + map{key}
	… on each (map) in (list-of-maps)
	sum ÷ (length of (list-of-maps))

=-
Join the contents of "list1" and "list2".
The original lists remain unchanged.
=-
join (list1) and (list2):
	starting with
		list : copy (list1)
	… apply
		append (item) to (list)
	… on each (item) in (list2)

==============================
 List functions
==============================

=-
The first value in the "list".
=-
first in (list) :
	list{1}

=-
The last value in the "list"
=-
last in (list) :
	list{length of (list)}

==============================
 Selection functions
==============================

=-
Executes statements in "block".
These statements are usually "this [] do []"
The difference between "when" and "do" - "when" is not transparent.
=-
when [block] :
	do (block)

=-
If "option" block is true, return executed "result".
The transparent return breaks out of the "when" block.
=-
this [option] do [result] ::
	if (do (option))
		return do (result)

==============================
 Numeric functions
==============================

=-
Increment numeric variable "x".
=-
inc (#x) :
	#x : #x + 1

=-
Decrement numeric variable "x".
=-
dec (#x) :
	#x : #x - 1

=-
The absolute value of "number".
=-
absolute (number) :
	if (number < 0)
		return -1 × number
	number

=-
Whether or not "number" is divisible by "div".
=-
(number) is divisible by (div) :
	return number % div = 0

=-
A random integer from "start" to "finish" inclusive.
=-
random from (start) to (finish) :
	if (start < finish)
		return random (1 + finish - start) + start - 1
	random (1 + start - finish) + finish - 1

=-
The square of "number".
=-
(number) squared/²:
	number × number

=-
Return true 50% of the time.
=-
coin toss :
	random 2 = 1

=-
The Euclidean distance from "a" to "b".
"a" and "b" are map values with keys "x" and "y".
=-
distance from (a) to (b) :
	δx : b{x} - a{x}
	δy : b{y} - a{y}
	√((δx)² + (δy)²)

==============================
 String functions
==============================

=-
Joins the string versions of the elements in "list".
=-
join (list) :
	string : ""
	for each (item) in (list) do
		string : string ⊕ item

=-
Joins the "list" with "separator" between elements.
=-
join (list) with separator (separator) :
	string : ""
	for each (item) in (list) keeping (count) do
		if (count = length of (list))
			return string ⊕ ((item) as string)
		string : string ⊕ ((item) as string) ⊕ separator

=-
The "list" as a string.
=-
(list) as string :
	if (not ((list) is a "list"))
		return list
	"{" ⊕ (join (list) with separator ", ") ⊕ "}"

=-
Print the "list" as a string.
=-
(list) as string _ :
	((list) as string) _

=-
Print the "list" as a string followed by a space.
=-
(list) as string __ :
	((list) as string) __

=-
Print the "list" as a string followed by a new line.
=-
(list) as string ↲ :
	((list) as string) ↲
