	-====================-
==============================
 The Remix standard library
==============================
	-====================-

"Standard library loaded." ↲

==============================
 Simple print functions
==============================

=-
Print a new line character.
=-
new line :
	↲

=-
Print the "VALUE" followed by a space.
=-
VALUE _ :
	print VALUE
	print " "

==============================
 Boolean functions
==============================

=-
Negate the "VALUE".
=-
not VALUE :
	if VALUE
		return false
	true

=-
The boolean "and" operation.
=-
VALUEA and VALUEB :
	if (not VALUEA)
		return false
	if (not VALUEB)
		return false
	true

=-
The boolean "or" operation.
=-
VALUEA or VALUEB :
	if VALUEA
		return true
	if VALUEB
		return true
	false

==============================
 Looping functions
==============================

=-
Run "BLOCK" for each "ITEM" in the "SEQUENCE".
"BLOCK" will usually use the variable passed as "ITEM".
Return either the last statement VALUE or whatever is returned from "BLOCK".
A sequence here is a list, range, map, string or sequence object.
=-
for each #ITEM in SEQUENCE /do [BLOCK] :
	POS : start SEQUENCE
	do
		if (end POS)
			return LAST
		#ITEM : next POS
		- A return in the "BLOCK" following breaks out of the loop, with its result.
		LAST : do BLOCK
		redo

=-
Run "BLOCK" for each "NUMBER" from "START" to "FINISH".
=-
for each #NUMBER from START to FINISH /do [BLOCK] :
	for each #NUMBER in (START to FINISH) do BLOCK

=-
Run "BLOCK" for each "NUMBER" from "START" to "FINISH" in steps of "STEP".
=-
for each #NUMBER from START to FINISH in steps of STEP /do [BLOCK]:
	if (START < FINISH)
		TEST : [#NUMBER ≤ FINISH]
	… otherwise
		TEST : [#NUMBER ≥ FINISH]
	#NUMBER : START
	while TEST do
		LAST : do BLOCK
		#NUMBER : #NUMBER + STEP
	LAST

=-
Run "BLOCK" for each "ITEM" in the "SEQUENCE" at all positions from "START" to "FINISH".
"START" to "FINISH" can go backwards.
"BLOCK" will usually use the variable passed as "ITEM".
A sequence here is a list, range or string.
=-
for each #ITEM in SEQUENCE from position START to FINISH /do [BLOCK] :
	for each POS from START to FINISH do
		#ITEM : POS in SEQUENCE
		do BLOCK

=-
Run "BLOCK" for each "ITEM" in the "SEQUENCE" keeping count in "COUNT".
A sequence here is a list, range, map, string or sequence object.
=-
for each #ITEM in SEQUENCE keeping #COUNT /do [BLOCK] :
	#COUNT : 0
	for each #ITEM in SEQUENCE do
		inc #COUNT
		do BLOCK

=-
Repeat the "BLOCK" for ever.
=-
repeat [BLOCK] forever :
	do BLOCK
	redo

=-
Repeat the "BLOCK" "COUNT" number of times.
=-
repeat [BLOCK] COUNT times :
	if (COUNT ≤ 0)
		return LAST ; none if unassigned
	LAST : do BLOCK
	COUNT : COUNT - 1
	redo

=-
Repeat the "BLOCK" "COUNT" number of times.
=-
repeat COUNT times [BLOCK] :
	repeat BLOCK COUNT times

=-
Repeat the "BLOCK" until the "CONDITION" is true.
=-
repeat [BLOCK] until [CONDITION] :
	LAST : do BLOCK
	if CONDITION
		return LAST
	redo

=-
While a "CONDITION" is true keep doing "BLOCK".
=-
while [CONDITION] /do [BLOCK] :
	if (not CONDITION)
		return LAST
	LAST : do BLOCK
	redo

==============================
 LIST create functions
==============================

=-
Filter "LIST" using "CONDITION-BLOCK" on each "ITEM" keeping "KEEP-BLOCK".
The blocks commonly refer to "ITEM".
=-
filter LIST by #ITEM where [CONDITION-BLOCK] keeping [KEEP-BLOCK] :
	NEW-LIST : {}
	for each #ITEM in LIST do
		if CONDITION-BLOCK
			append (do KEEP-BLOCK) to NEW-LIST
	NEW-LIST

=-
Filter "LIST" using "CONDITION-BLOCK" on each "ITEM".
The block commonly refers to "ITEM".
=-
filter LIST by #ITEM where [CONDITION-BLOCK] :
	filter LIST by #ITEM where CONDITION-BLOCK keeping [#ITEM]

=-
Collect items from "LIST" until "CONDITION" is true.
The "CONDITION" is checked before adding the "ITEM".
=-
keep #ITEM from LIST until [CONDITION] :
	NEW-LIST : {}
	for each #ITEM in LIST do
		if CONDITION
			return
		append #ITEM to NEW-LIST
	NEW-LIST

=-
Collect ITEMs from "LIST" where "CONDITION" is true,
stopping when "TERMINATION" becomes true.
The conditions are checked before adding the "ITEM".
=-
keep #ITEM from LIST where [CONDITION] until [TERMINATION] :
	RESULT : {}
	for each #ITEM in LIST do
		if TERMINATION
			return
		if CONDITION
			append #ITEM to RESULT
	RESULT

=-
Create a new LIST by applying "BLOCK" to each element of "LIST".
"BLOCK" will usually use the variable passed as "ITEM".
=-
apply [BLOCK] to each #ITEM from LIST :
	NEW-LIST : {}
	for each #ITEM in LIST do
		append (do BLOCK) to NEW-LIST
	NEW-LIST

=-
Create a new LIST by applying "BLOCK" "N" times.
=-
apply [BLOCK] N times :
	NEW-LIST : {}
	repeat
		append (do BLOCK) to NEW-LIST
	… N times
	NEW-LIST

==============================
 LIST reduce functions
==============================

=-
Can be used to construct LIST reduce functions.
"INITIAL" is executed first.
Then each "ITEM" in the "SEQUENCE" is executed in the "BLOCK".
A sequence here is a list, range, map, string or sequence object.
=-
starting with [INITIAL] apply [BLOCK] on each #ITEM in SEQUENCE :
	do INITIAL
	for each #ITEM in SEQUENCE do BLOCK

=-
Sum the "LIST" values.
=-
sum LIST :
	starting with
		SUM : 0
	… apply
		SUM : SUM + NUMBER
	… on each NUMBER in LIST

=-
Multiply the "LIST" values.
=-
product LIST:
	starting with
		PRODUCT : 1
	… apply
		PRODUCT : PRODUCT × NUMBER
	… on each NUMBER in LIST

=-
Find the average of the elements in the "LIST".
=-
average of LIST :
	starting with
		SUM : 0.0
	… apply
		SUM : SUM + ITEM
	… on each ITEM in LIST
	SUM ÷ (LIST length)

=-
Find the average of "KEY" elements in the "LIST-of-MAPS".
The "KEY" should be passed as a string.
=-
average KEY of LIST-of-MAPS :
	starting with
		SUM : 0.0
	… apply
		SUM : SUM + MAP {KEY}
	… on each MAP in LIST-of-MAPS
	SUM ÷ (LIST-of-MAPS length)

=-
Join the contents of "LIST1" and "LIST2".
The original lists remain unchanged.
=-
join LIST1 and LIST2 :
	starting with
		LIST : copy LIST1
	… apply
		append ITEM to LIST
	… on each ITEM in LIST2

==============================
 String functions
==============================

=-
Concatenate the "STRING" "N" times.
=-
STRING N times :
	RESULT : STRING
	repeat
		RESULT : RESULT ⊕ STRING
	… (N - 1) times
	RESULT

=-
Adds an 's' to "WORD" if plural, "NUMBER" > 1.
=-
pluralize WORD for NUMBER :
	if (NUMBER > 1)
		WORD ⊕ "s"
	… otherwise
		WORD

==============================
 LIST string functions
==============================

=-
Joins the string versions of the elements in "LIST".
=-
join LIST :
	STRING : ""
	for each ITEM in LIST do
		STRING : STRING ⊕ ITEM

=-
Joins the "LIST" with "SEPARATOR" between elements.
=-
join LIST with separator SEPARATOR :
	STRING : ""
	for each ITEM in LIST keeping COUNT do
		if (COUNT = LIST length)
			return STRING ⊕ (ITEM as string)
		STRING : STRING ⊕ (ITEM as string) ⊕ SEPARATOR

=-
The "LIST" as a string.
=-
LIST as string :
	if (not (LIST is a "LIST"))
		return LIST
	"{" ⊕ join LIST with separator ", " ⊕ "}"

==============================
 LIST functions
==============================

=-
	Append "VALUE" to the end of "LIST".
=-
to LIST append VALUE :
	append VALUE to LIST

=-
The first VALUE in the "LIST".
=-
first in LIST :
	LIST {1}

=-
The last VALUE in the "LIST".
=-
last in LIST :
	LIST {LIST length}

=-
Is the "SEQUENCE" empty?
A sequence here is a list, range, map, string or sequence object.
=-
no/empty SEQUENCE :
	SEQUENCE length = 0

=-
Choose a random ITEM from the "LIST".
=-
choose from LIST :
	LIST {random (LIST length)}

==============================
 Map functions
==============================

=-
Merge the "EXTRA" map into "MAP".
"MAP" is modified.
=-
merge EXTRA into MAP :
	for each ITEM in EXTRA do
		MAP {ITEM} : EXTRA {ITEM}

==============================
 Selection functions
==============================

=-
Executes statements in "BLOCK".
These statements are usually "[] do []"
The difference between "when" and "do" - "when" is not transparent.
=-
when [BLOCK] :
	do BLOCK

=-
If "OPTION" BLOCK is true, return executed "RESULT".
Used in a "when" BLOCK.
The transparent return breaks out of the "when".
=-
/this [OPTION] do [RESULT] ::
	if (do OPTION)
		return do RESULT

==============================
 Numeric functions
==============================

=-
Increment numeric variable "X".
=-
inc #X :
	#X : #X + 1

=-
Decrement numeric variable "X".
=-
dec #X :
	#X : #X - 1

=-
Increment numeric variable "X".
Return the previous VALUE.
=-
#X inc :
	#X : #X + 1
	#X - 1

=-
Decrement numeric variable "X".
Return the previous VALUE.
=-
#X dec :
	#X : #X - 1
	#X + 1

=-
Add "VALUE" to variable "X".
=-
add VALUE to #X :
	#X : #X + VALUE

=-
Subtract "VALUE" from variable "X".
=-
subtract VALUE from #X :
	#X : #X - VALUE

=-
Multiply variable "X" by "VALUE".
=-
multiply #X by VALUE :
	#X : #X × VALUE

=-
Divide variable "X" by "VALUE".
=-
divide #X by VALUE :
	#X : #X ÷ VALUE

=-
The absolute value of "NUMBER".
=-
absolute NUMBER :
	if (NUMBER < 0)
		return -NUMBER
	NUMBER

=-
Is "NUMBER" divisible by "DIV"?
=-
NUMBER is divisible by DIV :
	return NUMBER % DIV = 0

=-
A random integer from "START" to "FINISH" inclusive.
=-
random from START to FINISH :
	if (START < FINISH)
		return random (FINISH - START + 1) + START - 1
	random (START - FINISH + 1) + FINISH - 1

=-
The square of "NUMBER".
=-
NUMBER squared/sqrd/²:
	NUMBER × NUMBER

=-
Return true 50% of the time.
=-
coin toss :
	random 2 = 1

=-
The Euclidean distance from "A" to "B".
"A" and "B" are map values with keys "x" and "y".
=-
distance from A to B :
	Xδ : B {x} - A {x}
	Yδ : B {y} - A {y}
	√(Xδ ² + Yδ ²)

=-
Radian equivalent of "ANGLE" degrees.
=-
ANGLE degrees as radians :
	ANGLE ÷ 180.0 × π

=-
Degree equivalent of "ANGLE" radians.
=-
ANGLE radians as degrees :
	ANGLE ÷ π × 180.0

==============================
 Testing functions
==============================

=-
Create a test of "CODE" with expected "RESULT" described by "DESCRIPTION".
=-
DESCRIPTION [CODE] expected RESULT :
	{ "description" : DESCRIPTION, "code" : CODE, "expected" : RESULT }

=-
Create a test of "CODE" with expected "RESULT".
=-
[CODE] expected RESULT :
	"" CODE expected RESULT

=-
Make a group of tests out of "LIST-of-TESTS" and run all tests.
=-
test LIST-of-TESTS :
	TEST-OBJECT : create
		TESTS : LIST-of-TESTS
		PASSING : 0
		FAILING : 0

		assert test NUMBER DESCRIPTION [CODE] produces EXPECTED :
			if (DESCRIPTION ≠ "")
				"\"", DESCRIPTION, "\"" ↲
			… otherwise
				"Test #", NUMBER ↲

			RESULT : do CODE

			if (RESULT = EXPECTED)
				inc PASSING
				"  Passed" ↲
			… otherwise
				inc FAILING
				"  Failed: produces ", RESULT, ", should be ", EXPECTED ↲

		execute MY tests :
			"Starting tests: " ↲
			for each TEST in TESTS keeping TEST-NUMBER do
				assert test TEST-NUMBER (TEST {"description"})
				… (TEST {"code"}) produces (TEST {"expected"})
			↲
			TEST-STRING : TESTS length ⊕ " " ⊕ (pluralize "Test" for (TESTS length))
			TEST-STRING ↲
			"=" (TEST-STRING length) times ↲
			"Passing : ", PASSING ↲
			"Failing : ", FAILING ↲

	execute TEST-OBJECT tests

==============================
 Common library functions
==============================
graphics lib :
	include "remixPrograms/graphics.rem"
