	-====================-
==============================
 The Remix standard library
==============================
	-====================-

"Standard library loaded." ↲

==============================
 Simple print functions
==============================

=-
Print a new line character.
=-
new line :
	↲

=-
Print the "value" followed by a space.
=-
(value) _ :
	print (value)
	print " "

==============================
 Boolean functions
==============================

=-
Negate the "value".
=-
not (value) :
	if (value)
		return false
	true

=-
The boolean "and" operation.
=-
(valueA) and (valueB) :
	if (not (valueA))
		return false
	if (not (valueB))
		return false
	true

=-
The boolean "or" operation.
=-
(valueA) or (valueB) :
	if (valueA)
		return true
	if (valueB)
		return true
	false

==============================
 Looping functions
==============================

=-
Run "block" for each "item" in the "sequence".
"block" will usually use the variable passed as "item".
Return either the last statement value or whatever is returned from "block".
A sequence is a list, range, map or string.
=-
for each (#item) in (sequence) do [block] :
	pos : start (sequence)
	do
		if (end (pos))
			return last
		#item : next (pos)
		- A return in the "block" following breaks out of the loop, with its result.
		last : do (block)
		redo

=-
Run "block" for each "number" from "start" to "finish".
=-
for each (#number) from (start) to (finish) do [block] :
	for each (#number) in ((start) to (finish)) do (block)

=-
Run "block" for each "number" from "start" to "finish" in steps of "step".
=-
for each (#number) from (start) to (finish) in steps of (step) do [block]:
	if (start < finish)
		test : [#number ≤ finish]
	… otherwise
		test : [#number ≥ finish]
	#number : start
	while (test) do
		last : do (block)
		#number : #number + step
	last

=-
Run "block" for each "item" in the "sequence" at all positions from "start" to "finish".
"start" to "finish" can go backwards.
"block" will usually use the variable passed as "item".
A sequence here is a list, range or string.
=-
for each (#item) in (sequence) from position (start) to (finish) do [block] :
	for each (pos) from (start) to (finish) do
		#item : (pos) in (sequence)
		do (block)

=-
Run "block" for each "item" in the "sequence" keeping count in "count".
A sequence is a list, range, map or string.
=-
for each (#item) in (sequence) keeping (#count) do [block] :
	#count : 0
	for each (#item) in (sequence) do
		inc (#count)
		do (block)

=-
Repeat the "block" for ever.
=-
repeat [block] forever :
	do (block)
	redo

=-
Repeat the "block" "count" number of times.
=-
repeat [block] (count) times :
	if (count ≤ 0)
		return last
	last : do (block)
	count : count - 1
	redo

=-
Repeat the "block" until the "condition" is true.
=-
repeat [block] until [condition] :
	last : do (block)
	if (condition)
		return last
	redo

=-
While a "condition" is true keep doing "block".
=-
while [condition] do [block] :
	if (not (condition))
		return last
	last : do (block)
	redo

==============================
 List create functions
==============================

=-
Filter "list" using "condition-block" on each "item".
=-
filter (list) by (#item) where [condition-block] :
	new-list : {}
	for each (#item) in (list) do
		if (condition-block)
			append (#item) to (new-list)
	new-list

=-
Collect items from "list" until "condition" is true.
The "condition" is checked before adding the "item".
=-
keep (#item) from (list) until [condition] :
	new-list : {}
	for each (#item) in (list) do
		if (condition)
			return
		append (#item) to (new-list)
	new-list

=-
Collect items from "list" where "condition" is true,
stopping when "termination" becomes true.
The conditions are checked before adding the "item".
=-
keep (#item) from (list) where [condition] until [termination] :
	result : {}
	for each (#item) in (list) do
		if (termination)
			return
		if (condition)
			append (#item) to (result)
	result

=-
Create a new list by applying "block" to each element of "list".
"block" will usually use the variable passed as "item".
=-
apply [block] to each (#item) from (list) :
	new-list : {}
	for each (#item) in (list) do
		append (do (block)) to (new-list)
	new-list

=-
Create a new list by applying "block" "n" times.
=-
apply [block] (n) times :
	new-list : {}
	repeat
		append (do (block)) to (new-list)
	… (n) times
	new-list

==============================
 List reduce functions
==============================

=-
Can be used to construct list reduce functions.
"initial" is executed first.
Then each "item" in the "sequence" is executed in the "block".
A sequence is a list, range, map or string.
=-
starting with [initial] apply [block] on each (#item) in (sequence) :
	do (initial)
	for each (#item) in (sequence) do
		do (block)

=-
Sum the "list" values.
=-
sum (list) :
	starting with
		sum : 0
	… apply
		sum : sum + number
	… on each (number) in (list)

=-
Multiply the "list" values.
=-
product (list):
	starting with
		product : 1
	… apply
		product : product × number
	… on each (number) in (list)

=-
Find the average of the elements in the "list".
=-
average of (list) :
	starting with
		sum : 0.0
	… apply
		sum : sum + item
	… on each (item) in (list)
	sum ÷ ((list) length)

=-
Find the average of "key" elements in the "list-of-maps".
The "key" should be passed as a string.
=-
average (key) of (list-of-maps) :
	starting with
		sum : 0.0
	… apply
		sum : sum + map{key}
	… on each (map) in (list-of-maps)
	sum ÷ ((list-of-maps) length)

=-
Join the contents of "list1" and "list2".
The original lists remain unchanged.
=-
join (list1) and (list2):
	starting with
		list : copy (list1)
	… apply
		append (item) to (list)
	… on each (item) in (list2)

==============================
 String functions
==============================

=-
Concatenate the "string" "number" times.
=-
(string) (number) times :
	result : string
	repeat
		result : result ⊕ string
	… (number - 1) times
	result

==============================
 List string functions
==============================

=-
Joins the string versions of the elements in "list".
=-
join (list) :
	string : ""
	for each (item) in (list) do
		string : string ⊕ item

=-
Joins the "list" with "separator" between elements.
=-
join (list) with separator (separator) :
	string : ""
	for each (item) in (list) keeping (count) do
		if (count = (list) length)
			return string ⊕ ((item) as string)
		string : string ⊕ ((item) as string) ⊕ separator

=-
The "list" as a string.
=-
(list) as string :
	if (not ((list) is a "list"))
		return list
	"{" ⊕ join (list) with separator ", " ⊕ "}"

==============================
 List functions
==============================

=-
The first value in the "list".
=-
first in (list) :
	list{1}

=-
The last value in the "list"
=-
last in (list) :
	list{(list) length}

=-
Is the "sequence" empty?
A sequence is a list, range, map or string.
=-
no/empty (sequence) :
	(sequence) length = 0

==============================
 Map functions
==============================

=-
Merge the "extra" map into "map".
"map" is modified.
=-
merge (extra) into (map) :
	for each (item) in (extra) do
		map{item} : extra{item}

==============================
 Selection functions
==============================

=-
Executes statements in "block".
These statements are usually "[] do []"
The difference between "when" and "do" - "when" is not transparent.
=-
when [block] :
	do (block)

=-
If "option" block is true, return executed "result".
Used in a "when" block.
The transparent return breaks out of the "when".
=-
/this [option] do [result] ::
	if (do (option))
		return do (result)

==============================
 Numeric functions
==============================

=-
Increment numeric variable "x".
=-
inc (#x) :
	#x : #x + 1

=-
Decrement numeric variable "x".
=-
dec (#x) :
	#x : #x - 1

=-
Increment numeric variable "x".
Return the previous value.
=-
(#x) inc :
	#x : #x + 1
	#x - 1

=-
Decrement numeric variable "x".
Return the previous value.
=-
(#x) dec :
	#x : #x - 1
	#x + 1
=-
The absolute value of "number".
=-
absolute (number) :
	if (number < 0)
		return -number
	number

=-
Is "number" divisible by "div"?
=-
(number) is divisible by (div) :
	return number % div = 0

=-
A random integer from "start" to "finish" inclusive.
=-
random from (start) to (finish) :
	if (start < finish)
		return random (finish - start + 1) + start - 1
	random (start - finish + 1) + finish - 1

=-
The square of "number".
=-
(number) squared/²:
	number × number

=-
Return true 50% of the time.
=-
coin toss :
	random 2 = 1

=-
The Euclidean distance from "a" to "b".
"a" and "b" are map values with keys "x" and "y".
=-
distance from (a) to (b) :
	δx : b{x} - a{x}
	δy : b{y} - a{y}
	√((δx)² + (δy)²)

=-
Radian equivalent of "angle" degrees.
=-
(angle) degrees as radians :
	angle ÷ 180.0 × π

=-
Degree equivalent of "angle" radians.
=-
(angle) radians as degrees :
	angle ÷ π × 180.0

==============================
 Testing functions
==============================

=-
Create a test of "code" with expected "result" described by "description".
=-
(description) [code] expected (result) :
	{ description : description, code : code, expected : result }

=-
Create a test of "code" with expected "result".
=-
[code] expected (result) :
	"" (code) expected (result)

=-
Make a group of tests out of "list-of-tests" and run all tests.
=-
test (list-of-tests) :
	test-object : create
		tests : list-of-tests
		passing : 0
		failing : 0

		assert test (number) (description) [code] produces (expected) :
			result : do (code)

			if (description ≠ "")
				"\"", description, "\"" ↲
			… otherwise
				"Test #", number ↲

			if (result = expected)
				inc (passing)
				"  Passed" ↲
			… otherwise
				inc (failing)
				"  Failed: produces ", result, ", should be ", expected ↲

		execute tests (me) :
			"Starting tests: " ↲
			for each (test) in (tests) keeping (test-number) do
				assert test (test-number) (test{"description"})
				… (test{"code"}) produces (test{"expected"})
			↲
			test-string : (tests) length ⊕ " Tests"
			test-string ↲
			repeat ["=" ~] ((test-string) length) times. ↲
			"Passing : ", passing ↲
			"Failing : ", failing ↲

	execute tests (test-object)

==============================
 Common library functions
==============================
include graphics :
	include "remixPrograms/graphics.rem"