	-====================-
==============================
 The Remix standard library
==============================
	-====================-

==============================
 Simple print functions
==============================

=-
Print a new line character.
=-
new line :
	↲

=-
Print the "Value" followed by a space.
=-
Value _ :
	print Value
	print " "

==============================
 Boolean functions
==============================

=-
Negate the "Value".
=-
not Value :
	if Value
		return false
	true

=-
The boolean "and" operation.
=-
A and B :
	if (not A)
		return false
	if (not B)
		return false
	true

=-
The boolean "or" operation.
=-
A or B :
	if A
		return true
	if B
		return true
	false

==============================
 Looping functions
==============================

=-
Run "Block" for each "Item" in the "Sequence".
"Block" will usually use the variable passed as "Item".
Return either the last statement value or whatever is returned from "Block".
A sequence here is a list, range, map, string or sequence object.
=-
for each #Item in Sequence /do [Block] :
	Pos : start Sequence
	do
		if (end Pos)
			return Last
		#Item : next Pos
		- A return in the "Block" following breaks out of the loop, with its result.
		Last : do Block
		redo

=-
Run "Block" for each "Number" from "Start" to "Finish".
=-
for each #Number from Start to Finish /do [Block] :
	for each #Number in (Start to Finish) do Block

=-
Run "Block" for each "Number" from "Start" to "Finish" in steps of "Step".
=-
for each #Number from Start to Finish in steps of Step /do [Block]:
	if (Start < Finish)
		Test : [#Number ≤ Finish]
	… otherwise
		Test : [#Number ≥ Finish]
	#Number : Start
	while Test do
		Last : do Block
		#Number : #Number + Step
	Last

=-
Run "Block" for each "Item" in the "Sequence" at all positions from "Start" to "Finish".
"Start" to "Finish" can go backwards.
"Block" will usually use the variable passed as "Item".
A sequence here is a list, range, string or sequence object with a Pos in Sequence method.
=-
for each #Item in Sequence from position Start to Finish /do [Block] :
	for each Pos from Start to Finish do
		#Item : Pos in Sequence
		do Block

=-
Run "Block" for each "Item" in the "Sequence" keeping count in "Count".
A sequence here is a list, range, map, string or sequence object.
=-
for each #Item in Sequence keeping #Count /do [Block] :
	#Count : 0
	for each #Item in Sequence do
		inc #Count
		do Block

=-
Repeat the "Block" for ever.
=-
repeat [Block] forever :
	do Block
	redo

=-
Repeat the "Block" "Count" number of times.
=-
repeat [Block] Count times :
	if (Count ≤ 0)
		return Last ; none if unassigned
	Last : do Block
	Count : Count - 1
	redo

=-
Repeat the "Block" "Count" number of times.
=-
repeat Count times [Block] :
	repeat Block Count times

=-
Repeat the "Block" until the "Condition" is true.
=-
repeat [Block] until [Condition] :
	Last : do Block
	if Condition
		return Last
	redo

=-
While a "Condition" is true keep doing "Block".
=-
while [Condition] /do [Block] :
	if (not Condition)
		return Last
	Last : do Block
	redo

==============================
 List create functions
==============================

=-
Filter "List" using "Condition-Block" on each "Item" keeping "Keep-Block".
The Blocks commonly refer to "Item".
=-
filter List by #Item where [Condition-Block] keeping [Keep-Block] :
	new-List : {}
	for each #Item in List do
		if Condition-Block
			append (do Keep-Block) to new-List
	new-List

=-
Filter "List" using "Condition-Block" on each "Item".
The Block commonly refers to "Item".
=-
filter List by #Item where [Condition-Block] :
	filter List by #Item where Condition-Block keeping [#Item]

=-
Collect Items from "List" until "Condition" is true.
The "Condition" is checked before adding the "Item".
=-
keep #Item from List until [Condition] :
	new-List : {}
	for each #Item in List do
		if Condition
			return
		append #Item to new-List
	new-List

=-
Collect Items from "List" where "Condition" is true,
stopping when "Termination" becomes true.
The conditions are checked before adding the "Item".
=-
keep #Item from List where [Condition] until [Termination] :
	Result : {}
	for each #Item in List do
		if Termination
			return
		if Condition
			append #Item to Result
	Result

=-
Create a new List by applying "Block" to each element of "List".
"Block" will usually use the variable passed as "Item".
=-
apply [Block] to each #Item from List :
	new-List : {}
	for each #Item in List do
		append (do Block) to new-List
	new-List

=-
Create a new List by applying "Block" "N" times.
=-
apply [Block] N times :
	new-List : {}
	repeat
		append (do Block) to new-List
	… N times
	new-List

==============================
 List reduce functions
==============================

=-
Can be used to construct List reduce functions.
"Initial" is executed first.
Then each "Item" in the "Sequence" is executed in the "Block".
A sequence here is a list, range, map, string or sequence object.
=-
starting with [Initial] apply [Block] on each #Item in Sequence :
	do Initial
	for each #Item in Sequence do Block

=-
Sum the "List" values.
=-
sum List :
	starting with
		Sum : 0
	… apply
		Sum : Sum + Number
	… on each Number in List

=-
Multiply the "List" values.
=-
product List:
	starting with
		Product : 1
	… apply
		Product : Product × Number
	… on each Number in List

=-
Find the average of the elements in the "List".
=-
average of List :
	starting with
		Sum : 0.0
	… apply
		Sum : Sum + Item
	… on each Item in List
	Sum ÷ (List length)

=-
Find the average of "Key" elements in the "List-of-Maps".
The "Key" should be passed as a string.
=-
average Key of List-of-Maps :
	starting with
		Sum : 0.0
	… apply
		Sum : Sum + Map {Key}
	… on each Map in List-of-Maps
	Sum ÷ (List-of-Maps length)

=-
Join the contents of "List1" and "List2".
The original lists remain unchanged.
=-
join List1 and List2 :
	starting with
		List : copy List1
	… apply
		append Item to List
	… on each Item in List2

==============================
 String functions
==============================

=-
Concatenate the "String" "N" times.
=-
String N times :
	Result : String
	repeat
		Result : Result ⊕ String
	… (N - 1) times
	Result

=-
Adds an 's' to "Word" if plural, "Number" > 1.
=-
pluralize Word for Number :
	if (Number > 1)
		Word ⊕ "s"
	… otherwise
		Word

==============================
 List string functions
==============================

=-
Joins the string versions of the elements in "List".
=-
join List :
	String : ""
	for each Item in List do
		String : String ⊕ Item

=-
Joins the "List" with "Separator" between elements.
=-
join List with separator Separator :
	String : ""
	for each Item in List keeping Count do
		if (Count = List length)
			return String ⊕ (Item as string)
		String : String ⊕ (Item as string) ⊕ Separator

=-
The "List" as a string.
=-
List as string :
	if (not (List is a "List"))
		return List
	"{" ⊕ join List with separator ", " ⊕ "}"

==============================
 List functions
==============================

=-
	Append "Value" to the end of "List".
=-
to List append Value :
	append Value to List

=-
The first Value in the "List".
=-
first in List :
	List {1}

=-
The last Value in the "List".
=-
last in List :
	List {List length}

=-
Is the "Sequence" empty?
A sequence here is a list, range, map, string or sequence object.
=-
no/empty Sequence :
	Sequence length = 0

=-
Choose a random Item from the "List".
=-
choose from List :
	List {random (List length)}

==============================
 Map functions
==============================

=-
Merge the "Extra" map into "Map".
"Map" is modified.
=-
merge Extra into Map :
	for each Item in Extra do
		Map {Item} : Extra {Item}

==============================
 Selection functions
==============================

=-
Executes statements in "Block".
These statements are usually "[] do []"
The difference between "when" and "do" - "when" is not transparent.
=-
when [Block] :
	do Block

=-
If "Option" Block is true, return executed "Result".
Used in a "when" Block.
The transparent return breaks out of the "when".
=-
/this [Option] do [Result] ::
	if (do Option)
		return do Result

==============================
 Numeric functions
==============================

=-
Increment numeric variable "X".
=-
inc #X :
	#X : #X + 1

=-
Decrement numeric variable "X".
=-
dec #X :
	#X : #X - 1

=-
Increment numeric variable "X".
Return the previous Value.
=-
#X inc :
	#X : #X + 1
	#X - 1

=-
Decrement numeric variable "X".
Return the previous Value.
=-
#X dec :
	#X : #X - 1
	#X + 1

=-
Add "Value" to variable "X".
=-
add Value to #X :
	#X : #X + Value

=-
Subtract "Value" from variable "X".
=-
subtract Value from #X :
	#X : #X - Value

=-
Multiply variable "X" by "Value".
=-
multiply #X by Value :
	#X : #X × Value

=-
Divide variable "X" by "Value".
=-
divide #X by Value :
	#X : #X ÷ Value

=-
The absolute value of "Number".
=-
absolute Number :
	if (Number < 0)
		return -Number
	Number

=-
Is "Number" divisible by "Div"?
=-
Number is divisible by Div :
	return Number % Div = 0

=-
A random integer from "Start" to "Finish" inclusive.
=-
random from Start to Finish :
	if (Start < Finish)
		return random (Finish - Start + 1) + Start - 1
	random (Start - Finish + 1) + Finish - 1

=-
The square of "Number".
=-
Number squared/sqrd/²:
	Number × Number

=-
Return true 50% of the time.
=-
coin toss :
	if (random 2 = 1)
		return true
	false

=-
The Euclidean distance from "A" to "B".
"A" and "B" are map values with keys "x" and "y".
=-
distance from A to B :
	Δx : B {"x"} - A {"x"}
	Δy : B {"y"} - A {"y"}
	√(Δx ² + Δy ²)

=-
Radian equivalent of "Angle" degrees.
=-
Angle degrees as radians :
	Angle ÷ 180.0 × π

=-
Degree equivalent of "Angle" radians.
=-
Angle radians as degrees :
	Angle ÷ π × 180.0

==============================
 Swapping functions
==============================

=-
Swap "A" with "B".
=-
#A swap #B :
	Temp : #A
	#A : #B
	#B : Temp

=-
Swap "List" element "This" with "That".
"List" can be a list or map.
"This" and "That" are indexes or keys.
=-
swap List element This with That :
	Temp : List {This}
	List {This} : List {That}
	List {That} : Temp

==============================
 Testing functions
==============================

=-
Create a test of "Code" with expected "Result" described by "Description".
=-
Description [Code] expected Result :
	{ "description" : Description, "code" : Code, "expected" : Result }

=-
Create a test of "Code" with expected "Result".
=-
[Code] expected Result :
	"" Code expected Result

=-
Make a group of tests out of "List-of-Tests" and run all tests.
=-
test List-of-Tests :
	Test-Object : create
		Tests : List-of-Tests
		Passing : 0
		Failing : 0

		assert test Number Description [Code] produces Expected :
			if (Description ≠ "")
				"\"", Description, "\"" ↲
			… otherwise
				"Test #", Number ↲

			Result : do Code

			if (Result = Expected)
				inc Passing
				"  Passed" ↲
			… otherwise
				inc Failing
				"  Failed: produces ", Result, ", should be ", Expected ↲

		execute MY tests :
			"Starting tests: " ↲
			for each Test in Tests keeping Test-Number do
				assert test Test-Number (Test {"description"})
				… (Test {"code"}) produces (Test {"expected"})
			↲
			Test-String : Tests length ⊕ " " ⊕ (pluralize "Test" for (Tests length))
			Test-String ↲
			"=" (Test-String length) times ↲
			"Expected : ", Passing ↲
			"Failing : ", Failing ↲

	execute Test-Object tests

==============================
 Common library functions
==============================

graphics lib :
	include "remixPrograms/graphics.rem"

-==============================-

"Standard library loaded." ↲