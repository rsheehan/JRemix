LIST : apply [random 100] 400 times

"unsorted: ", LIST ↲

check for missing values in LIST
insertion sort LIST

"sorted: ", LIST ↲

----------

check for missing values in LIST :
	COUNT-of-VALUES : apply [0] 100 times
	count each item in LIST into COUNT-of-VALUES
	for each ITEM in COUNT-of-VALUES keeping COUNT do
		if (ITEM = 0)
			COUNT, " is missing" ↲

count each item in LIST into TALLY :
	for each ITEM in LIST do
		TALLY {ITEM} : TALLY {ITEM} + 1

================
 Insertion Sort
================

insertion sort LIST :
	for each POSITION from 2 to (length of LIST) do
		for each THIS from POSITION to 2 do
			swap if element to the left is greater than THIS in LIST

swap if element to the left is greater than THIS in LIST ::
- N.B. transparent short circuit
	LEFT : THIS - 1
	if (LIST {LEFT} > LIST {THIS})
		swap LIST element THIS with LEFT
	… otherwise
		return

swap LIST element THIS with THAT :
	TEMP : LIST {THIS}
	LIST {THIS} : LIST {THAT}
	LIST {THAT} : TEMP
